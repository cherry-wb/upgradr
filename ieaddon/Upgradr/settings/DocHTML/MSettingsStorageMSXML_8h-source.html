<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SettingsStorage: MSettingsStorageMSXML.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.5 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a></div>
<h1>MSettingsStorageMSXML.h</h1><div class="fragment"><pre>00001 <span class="comment">//========================================================================================</span>
00002 <span class="comment">//</span>
00003 <span class="comment">// Module:          SettingsStorage</span>
00004 <span class="comment">// Author:          Pascal Hurni</span>
00005 <span class="comment">// Creation Date:   25.05.2004</span>
00006 <span class="comment">//</span>
00007 <span class="comment">// Copyright 2003 Mortimer Systems</span>
00008 <span class="comment">// This software is free. I grant you a non-exclusive license to use it.</span>
00009 <span class="comment">//</span>
00010 <span class="comment">// Modifications:</span>
00011 <span class="comment">//</span>
00012 <span class="comment">//  2004-05-11  By Pascal Hurni</span>
00013 <span class="comment">//</span>
00014 <span class="comment">//</span>
00015 <span class="comment">//========================================================================================</span>
00016 
00017 <span class="preprocessor">#ifndef __MORTIMER_SETTINGSSTORAGEMSXML_H__</span>
00018 <span class="preprocessor"></span><span class="preprocessor">#define __MORTIMER_SETTINGSSTORAGEMSXML_H__</span>
00019 <span class="preprocessor"></span>
00020 <span class="preprocessor">#include "MSettingsStorage.h"</span>
00021 
00022 <span class="preprocessor">#import "msxml3.dll" raw_interfaces_only</span>
00023 <span class="preprocessor"></span><span class="keyword">using</span> <span class="keyword">namespace </span>MSXML2;
00024 
00025 
00026 <span class="preprocessor">#ifndef MAX_PATH</span>
00027 <span class="preprocessor"></span><span class="preprocessor">#define MAX_PATH 256</span>
00028 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00029 <span class="preprocessor"></span>
00030 <span class="preprocessor">#ifndef DOXYGEN_SHOULD_SKIP_THIS</span>
00031 <span class="preprocessor"></span><span class="keyword">namespace </span>Mortimer
00032 {
00033 <span class="preprocessor">#endif</span>
00034 <span class="preprocessor"></span>
<a name="l00038"></a><a class="code" href="classCSettingsStorageMSXML.html">00038</a> <span class="keyword">class </span><a class="code" href="classCSettingsStorageMSXML.html">CSettingsStorageMSXML</a> : <span class="keyword">public</span> <a class="code" href="classCSettingsStorage.html">CSettingsStorage</a>
00039 {
00040 <span class="keyword">protected</span>:
00041     IXMLDOMDocumentPtr m_DocumentPtr;
00042     IXMLDOMNodePtr m_NodePtr;               <span class="comment">// The root node from where to get/put children elements</span>
00043     IXMLDOMNodePtr m_ParentNodePtr;         <span class="comment">// The parent of the root node.</span>
00044     TCHAR m_NodeName[MAX_PATH];             <span class="comment">// The m_NodePtr related node name.</span>
00045     <span class="keywordtype">bool</span> m_UseParentAsNode;                 <span class="comment">// Use the given parent as the node.</span>
00046 
00047     <span class="comment">// Used for collections</span>
00048     IXMLDOMNodeListPtr m_CollectionNodeListPtr;
00049     IXMLDOMNodePtr m_CollectionNodePtr;
00050     IXMLDOMNodePtr m_CollectionCurrentItemNodePtr;
00051     TCHAR m_CollectionItemName[MAX_PATH];
00052     <span class="keywordtype">bool</span> m_ProcessingAloneCollection;
00053 
00054 <span class="keyword">public</span>:
00055     <a class="code" href="classCSettingsStorageMSXML.html">CSettingsStorageMSXML</a>() : m_ProcessingAloneCollection(<span class="keyword">false</span>)
00056     {
00057     }
00058 
00059     <a class="code" href="classCSettingsStorageMSXML.html">CSettingsStorageMSXML</a>(IXMLDOMDocumentPtr DocPtr, IXMLDOMNodePtr NodePtr, LPCTSTR SubName, <span class="keywordtype">bool</span> UseParentAsNode)
00060         : m_DocumentPtr(DocPtr), m_ParentNodePtr(NodePtr), m_UseParentAsNode(UseParentAsNode), m_ProcessingAloneCollection(<span class="keyword">false</span>)
00061     {
00062         _tcscpy(m_NodeName, SubName);
00063         m_ProcessingAloneCollection = <span class="keyword">false</span>;
00064     }
00065 
00066     <a class="code" href="classCSettingsStorage.html">CSettingsStorage</a> *CreateSubStorage(LPCTSTR SubName)
00067     {
00068         <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classCSettingsStorageMSXML.html">CSettingsStorageMSXML</a>(m_DocumentPtr, m_NodePtr, SubName, <span class="keyword">false</span>);
00069     }
00070 
00071     <span class="keywordtype">bool</span> OnBeforeLoad()
00072     {
00073         <span class="keywordflow">if</span> (m_UseParentAsNode)
00074             m_NodePtr = m_ParentNodePtr;
00075         <span class="keywordflow">else</span>
00076             m_NodePtr = GetChildNodeByName(m_ParentNodePtr, m_NodeName);
00077 
00078         <span class="keywordflow">return</span> m_NodePtr;
00079     }
00080 
00081     <span class="keywordtype">bool</span> OnAfterLoad()
00082     {
00083         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00084     }
00085 
00086     <span class="keywordtype">bool</span> OnBeforeSave()
00087     {
00088         <span class="keywordflow">if</span> (m_UseParentAsNode)
00089             m_NodePtr = m_ParentNodePtr;
00090         <span class="keywordflow">else</span>
00091             m_NodePtr = CreateChildNode(m_ParentNodePtr, m_NodeName);
00092 
00093         <span class="keywordflow">return</span> m_NodePtr;
00094     }
00095 
00096     <span class="keywordtype">bool</span> OnAfterSave()
00097     {
00098         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00099     }
00100 
00101     <span class="keywordtype">bool</span> ContinueOnError()
00102     {
00103         <span class="comment">// We want the system to read/write the most possible items, even if one fails</span>
00104         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00105     }
00106 
00107 <span class="keyword">public</span>:
00108     <span class="comment">//------------------------------------------------------------------------------------</span>
00109     <span class="comment">// Here are the type specific SaveLoad functions</span>
00110 
00111     <span class="comment">// Handy macro used for all simple types</span>
00112 <span class="preprocessor">    #define SSXF_SAVELOADITEM(type, token) inline bool SaveLoadItem(LPCTSTR szName, type&amp; Variable, bool bSave) \</span>
00113 <span class="preprocessor">    {   TCHAR Value[MAX_PATH]; \</span>
00114 <span class="preprocessor">        ULONG Size = MAX_PATH; \</span>
00115 <span class="preprocessor">        if (bSave) { \</span>
00116 <span class="preprocessor">            _stprintf(Value, _T(token), Variable); \</span>
00117 <span class="preprocessor">            Size = _tcslen(Value); \</span>
00118 <span class="preprocessor">            return SaveLoadItem(szName, Value, Size, bSave); \</span>
00119 <span class="preprocessor">        } else { \</span>
00120 <span class="preprocessor">            if (!SaveLoadItem(szName, Value, Size, bSave)) return false; \</span>
00121 <span class="preprocessor">            return 1 == _stscanf(Value, _T(token), &amp;Variable); \</span>
00122 <span class="preprocessor">    }   }</span>
00123 <span class="preprocessor"></span>
00124     SSXF_SAVELOADITEM(<span class="keywordtype">long</span>, <span class="stringliteral">"%d"</span>)
00125     SSXF_SAVELOADITEM(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>, <span class="stringliteral">"%u"</span>)
00126 
00127     SSXF_SAVELOADITEM(<span class="keywordtype">float</span>, <span class="stringliteral">"%f"</span>)
00128     SSXF_SAVELOADITEM(<span class="keywordtype">double</span>, <span class="stringliteral">"%lf"</span>)
00129 
00130     <span class="comment">// bool</span>
00131     <span class="keyword">inline</span> <span class="keywordtype">bool</span> SaveLoadItem(LPCTSTR szName, <span class="keywordtype">bool</span>&amp; Variable, <span class="keywordtype">bool</span> bSave)
00132     {
00133         <span class="keywordflow">if</span> (bSave)
00134             <span class="keywordflow">return</span> SaveLoadItem(szName, Variable ? _T(<span class="stringliteral">"TRUE"</span>) : _T(<span class="stringliteral">"FALSE"</span>), 6, bSave);
00135         <span class="keywordflow">else</span>
00136         {
00137             TCHAR Value[10];
00138             <span class="keywordflow">if</span> (!SaveLoadItem(szName, Value, <span class="keyword">sizeof</span>(Value), bSave)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00139             Variable = _tcscmp(Value, _T(<span class="stringliteral">"TRUE"</span>)) == 0;
00140             <span class="keywordflow">return</span> <span class="keyword">true</span>;
00141         }
00142     }
00143 
00144     <span class="comment">// TCHAR*</span>
00145     <span class="keyword">inline</span> <span class="keywordtype">bool</span> SaveLoadItem(LPCTSTR szName, TCHAR* Variable, ULONG&amp; Size, <span class="keywordtype">bool</span> bSave)
00146     {
00147         HRESULT hr;
00148 
00149         <span class="keywordflow">if</span> (bSave)
00150         {
00151             IXMLDOMElementPtr ElementPtr;
00152             IXMLDOMTextPtr ValuePtr;
00153             IXMLDOMNodePtr DummyNodePtr;
00154 
00155             hr = m_DocumentPtr-&gt;createElement(_bstr_t(szName), &amp;ElementPtr);
00156             <span class="keywordflow">if</span> (FAILED(hr))
00157                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00158 
00159             <span class="keywordflow">if</span> (_tcspbrk(Variable, _T(<span class="stringliteral">"&lt;&gt;&amp;"</span>)) != NULL)
00160                 hr = m_DocumentPtr-&gt;createCDATASection(_bstr_t(Variable), (MSXML2::IXMLDOMCDATASection**)&amp;ValuePtr);
00161             <span class="keywordflow">else</span>
00162                 hr = m_DocumentPtr-&gt;createTextNode(_bstr_t(Variable), &amp;ValuePtr);
00163             <span class="keywordflow">if</span> (FAILED(hr))
00164                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00165 
00166             hr = ElementPtr-&gt;appendChild(ValuePtr, &amp;DummyNodePtr);
00167             <span class="keywordflow">if</span> (FAILED(hr))
00168                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00169 
00170             <span class="keywordflow">if</span> (m_ProcessingAloneCollection)
00171                 hr = m_CollectionNodePtr-&gt;appendChild(ElementPtr, &amp;DummyNodePtr);
00172             <span class="keywordflow">else</span>
00173                 hr = m_NodePtr-&gt;appendChild(ElementPtr, &amp;DummyNodePtr);
00174             <span class="keywordflow">if</span> (FAILED(hr))
00175                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00176 
00177             <span class="keywordflow">return</span> <span class="keyword">true</span>;
00178         }
00179         <span class="keywordflow">else</span>
00180         {
00181             IXMLDOMNodePtr NodePtr;
00182 
00183             <span class="keywordflow">if</span> (m_ProcessingAloneCollection)
00184                 NodePtr = m_CollectionCurrentItemNodePtr;
00185             <span class="keywordflow">else</span>
00186                 NodePtr = GetChildNodeByName(m_NodePtr, szName);
00187 
00188             <span class="keywordflow">if</span> (NodePtr == NULL)
00189             {
00190                 Size = 0;
00191                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00192             }
00193 
00194             IXMLDOMNodePtr ValuePtr;
00195             hr = NodePtr-&gt;get_firstChild(&amp;ValuePtr);
00196             <span class="keywordflow">if</span> (FAILED(hr))
00197             {
00198                 Size = 0;
00199                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00200             }
00201 
00202             _variant_t ValueVariant;
00203             _bstr_t ValueText;
00204 
00205             <span class="comment">// When no child, don't get it. Will result in an empty string</span>
00206             <span class="keywordflow">if</span> (hr == S_OK)
00207             {
00208                 hr = ValuePtr-&gt;get_nodeValue(&amp;ValueVariant);
00209                 <span class="keywordflow">if</span> (hr != S_OK)
00210                 {
00211                     Size = 0;
00212                     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00213                 }
00214                 ValueText = ValueVariant;
00215             }
00216 
00217             <span class="keywordflow">if</span> (Variable == NULL)
00218             {
00219                 Size = ValueText.length()+1;
00220                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
00221             }
00222             <span class="keywordflow">if</span> (ValueText.length() &gt;= Size)
00223             {
00224                 Size = ValueText.length()+1;
00225                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00226             }
00227 
00228             <span class="keywordflow">if</span> ((TCHAR*)ValueText)
00229                 _tcsncpy(Variable, (TCHAR*)ValueText, Size);
00230             <span class="keywordflow">else</span>
00231                 *Variable = 0;
00232             <span class="keywordflow">return</span> <span class="keyword">true</span>;
00233         }
00234     }
00235 
00236     <span class="comment">// void*</span>
00237     <span class="keyword">inline</span> <span class="keywordtype">bool</span> SaveLoadItem(LPCTSTR szName, <span class="keywordtype">void</span>* Variable, ULONG Size, <span class="keywordtype">bool</span> bSave)
00238     {
00239         <span class="keywordflow">if</span> (bSave)
00240         {
00241             <span class="comment">// allocate memory for the hex string</span>
00242             ULONG StringSize = Size*3;
00243             TCHAR *pHexString = <span class="keyword">new</span> TCHAR[StringSize+1];
00244             <span class="keywordflow">if</span> (!pHexString)
00245                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00246 
00247             BYTE *pVar = (BYTE*)Variable;
00248             <span class="keywordflow">for</span> (ULONG i=0; i&lt;Size; i++)
00249             {
00250                 _stprintf(pHexString+i*3, <span class="stringliteral">"%02X "</span>, *pVar++);
00251             }
00252             pHexString[StringSize] = 0;
00253 
00254             <span class="keywordtype">bool</span> Result = SaveLoadItem(szName, pHexString, StringSize, bSave);
00255             <span class="keyword">delete</span> pHexString;
00256             <span class="keywordflow">return</span> Result;
00257         }
00258         <span class="keywordflow">else</span>
00259         {
00260             ULONG StringSize;
00261             <span class="keywordflow">if</span> (!SaveLoadItem(szName, (TCHAR*)NULL, StringSize, bSave))
00262                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00263 
00264             <span class="comment">// allocate memory for the hex string</span>
00265             TCHAR *pHexString = <span class="keyword">new</span> TCHAR[StringSize];
00266             <span class="keywordflow">if</span> (!pHexString)
00267                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00268 
00269             <span class="keywordflow">if</span> (!SaveLoadItem(szName, pHexString, StringSize, bSave))
00270                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00271 
00272             BYTE *pVar = (BYTE*)Variable;
00273             ULONG Val;
00274             <span class="keywordflow">for</span> (ULONG i=0; i&lt;Size; i++)
00275             {
00276                 _stscanf(pHexString+i*3, <span class="stringliteral">"%2x "</span>, &amp;Val);
00277                 *pVar++ = (BYTE)Val;
00278             }
00279 
00280             <span class="keyword">delete</span> pHexString;
00281             <span class="keywordflow">return</span> <span class="keyword">true</span>;
00282         }
00283     }
00284 
00285 <span class="keyword">protected</span>:
00286     <span class="keywordtype">bool</span> OnBeginCollection(LPCTSTR szName, UINT&amp; ItemCount, <span class="keywordtype">bool</span> bSave)
00287     {
00288         <span class="keywordflow">if</span> (bSave)
00289             m_CollectionNodePtr = CreateChildNode(m_NodePtr, szName);
00290         <span class="keywordflow">else</span>
00291             m_CollectionNodePtr = GetChildNodeByName(m_NodePtr, szName);
00292 
00293         <span class="keywordflow">if</span> (m_CollectionNodePtr == NULL)
00294             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00295 
00296         <span class="comment">// Generate the collection item name</span>
00297         _stprintf(m_CollectionItemName, <span class="stringliteral">"%s.Item"</span>, szName);
00298 
00299         <span class="keywordflow">if</span> (!bSave)
00300         {
00301             HRESULT hr;
00302 
00303             hr = m_CollectionNodePtr-&gt;get_childNodes(&amp;m_CollectionNodeListPtr);
00304             <span class="keywordflow">if</span> (FAILED(hr))
00305                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00306 
00307             LONG Count;
00308             hr = m_CollectionNodeListPtr-&gt;get_length(&amp;Count);
00309             <span class="keywordflow">if</span> (FAILED(hr))
00310                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00311 
00312             hr = m_CollectionNodeListPtr-&gt;reset();
00313             <span class="keywordflow">if</span> (FAILED(hr))
00314                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00315 
00316             ItemCount = Count;
00317         }
00318 
00319         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00320     }
00321 
00322     <span class="keywordtype">int</span> OnItemCollection(UINT Index, <a class="code" href="classCSettings.html">CSettings</a> &amp;variable, <span class="keywordtype">bool</span> bSave)
00323     {
00324         HRESULT hr;
00325         IXMLDOMNodePtr ItemNodePtr;
00326 
00327         <span class="keywordflow">if</span> (bSave)
00328         {
00329             <a class="code" href="classCSettingsStorageMSXML.html">CSettingsStorageMSXML</a> ItemStorage(m_DocumentPtr, m_CollectionNodePtr, m_CollectionItemName, <span class="keyword">false</span>);
00330             <span class="keywordflow">return</span> variable.<a class="code" href="classCSettings.html#a1">Save</a>(ItemStorage) ? 1 : 0;
00331         }
00332         <span class="keywordflow">else</span>
00333         {
00334             hr = m_CollectionNodeListPtr-&gt;get_item(Index, &amp;ItemNodePtr);
00335             <span class="keywordflow">if</span> (FAILED(hr) || !(<span class="keywordtype">bool</span>)ItemNodePtr)
00336                 <span class="keywordflow">return</span> 0;
00337 
00338             <span class="comment">// Ensure it is a valid Item element</span>
00339             BSTR bstrNode;
00340             <span class="keywordflow">if</span> (S_OK != ItemNodePtr-&gt;get_nodeName(&amp;bstrNode))
00341                 <span class="keywordflow">return</span> 0;
00342 
00343             _bstr_t NodeName(bstrNode, <span class="keyword">false</span>);
00344             <span class="keywordflow">if</span> (_tcscmp(m_CollectionItemName, (TCHAR*)NodeName) != 0)
00345                 <span class="keywordflow">return</span> 0;
00346 
00347             <a class="code" href="classCSettingsStorageMSXML.html">CSettingsStorageMSXML</a> ItemStorage(m_DocumentPtr, ItemNodePtr, m_CollectionItemName, <span class="keyword">true</span>);
00348             <span class="keywordflow">return</span> variable.<a class="code" href="classCSettings.html#a0">Load</a>(ItemStorage) ? 1 : 0;
00349         }
00350     }
00351 
00352     <span class="keywordtype">bool</span> OnEndCollection(<span class="keywordtype">bool</span> bSave)
00353     {
00354         m_CollectionNodeListPtr = NULL;
00355         m_CollectionNodePtr = NULL;
00356         m_CollectionCurrentItemNodePtr = NULL;
00357 
00358         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00359     }
00360 
00361     <span class="keywordtype">bool</span> OnBeginAloneCollection(LPCTSTR szName, UINT&amp; ItemCount, <span class="keywordtype">bool</span> bSave)
00362     {
00363         <span class="keywordflow">if</span> (!OnBeginCollection(szName, ItemCount, bSave))
00364             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00365 
00366         m_ProcessingAloneCollection = <span class="keyword">true</span>;
00367         m_pCollectionStorage = <span class="keyword">this</span>;
00368         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00369     }
00370 
00371     <span class="keywordtype">int</span> OnItemAloneCollection(UINT Index, <span class="keywordtype">bool</span> bSave, LPCTSTR &amp;ItemName)
00372     {
00373         ItemName = m_CollectionItemName;
00374 
00375         <span class="keywordflow">if</span> (bSave)
00376             <span class="keywordflow">return</span> 1;
00377         <span class="keywordflow">else</span>
00378         {
00379             HRESULT hr = m_CollectionNodeListPtr-&gt;get_item(Index, &amp;m_CollectionCurrentItemNodePtr);
00380             <span class="keywordflow">if</span> (FAILED(hr) || !(<span class="keywordtype">bool</span>)m_CollectionCurrentItemNodePtr)
00381                 <span class="keywordflow">return</span> 0;
00382 
00383             <span class="comment">// Ensure it is a valid Item element</span>
00384             BSTR bstrNode;
00385             <span class="keywordflow">if</span> (S_OK != m_CollectionCurrentItemNodePtr-&gt;get_nodeName(&amp;bstrNode))
00386                 <span class="keywordflow">return</span> 0;
00387 
00388             _bstr_t NodeName(bstrNode, <span class="keyword">false</span>);
00389             <span class="keywordflow">return</span> _tcscmp(m_CollectionItemName, (TCHAR*)NodeName) == 0 ? 1 : 0;
00390         }
00391     }
00392 
00393     <span class="keywordtype">bool</span> OnEndAloneCollection(<span class="keywordtype">bool</span> bSave)
00394     {
00395         <span class="keywordflow">if</span> (!OnEndCollection(bSave))
00396             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00397 
00398         m_ProcessingAloneCollection = <span class="keyword">false</span>;
00399         m_pCollectionStorage = NULL;
00400         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00401     }
00402 
00403 <span class="keyword">protected</span>:
00404     IXMLDOMNodePtr GetChildNodeByName(IXMLDOMNodePtr ParentNodePtr, LPCTSTR Name)
00405     {
00406         HRESULT hr;
00407         IXMLDOMNodeListPtr NodeListPtr;
00408         IXMLDOMNodePtr NodePtr;
00409 
00410         hr = ParentNodePtr-&gt;get_childNodes(&amp;NodeListPtr);
00411         <span class="keywordflow">if</span> (FAILED(hr))
00412             <span class="keywordflow">return</span> NULL;
00413 
00414         LONG Count;
00415         hr = NodeListPtr-&gt;get_length(&amp;Count);
00416         <span class="keywordflow">if</span> (FAILED(hr))
00417             <span class="keywordflow">return</span> NULL;
00418 
00419         hr = NodeListPtr-&gt;reset();
00420         <span class="keywordflow">if</span> (FAILED(hr))
00421             <span class="keywordflow">return</span> NULL;
00422 
00423         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; Count; i++)
00424         {
00425             hr = NodeListPtr-&gt;get_item(i, &amp;NodePtr);
00426             <span class="keywordflow">if</span> (SUCCEEDED(hr) &amp;&amp; (<span class="keywordtype">bool</span>)NodePtr)
00427             {
00428                 BSTR bstrItem;
00429                 hr = NodePtr-&gt;get_nodeName(&amp;bstrItem);
00430                 _bstr_t ItemText(bstrItem, <span class="keyword">false</span>);
00431                 <span class="keywordflow">if</span> ((hr==S_OK) &amp;&amp; (_tcscmp((TCHAR*)ItemText, Name) == 0))
00432                 {
00433                     <span class="keywordflow">return</span> NodePtr;
00434                 }
00435             }
00436         }
00437 
00438         <span class="keywordflow">return</span> NULL;
00439     }
00440 
00441     IXMLDOMNodePtr CreateChildNode(IXMLDOMNodePtr ParentNodePtr, LPCTSTR Name)
00442     {
00443         HRESULT hr;
00444         IXMLDOMElementPtr NodePtr;
00445 
00446         hr = m_DocumentPtr-&gt;createElement(_bstr_t(Name), &amp;NodePtr);
00447         <span class="keywordflow">if</span> (FAILED(hr))
00448             <span class="keywordflow">return</span> NULL;
00449 
00450         IXMLDOMNodePtr InsertedNodePtr;
00451         hr = ParentNodePtr-&gt;appendChild(NodePtr, &amp;InsertedNodePtr);
00452         <span class="keywordflow">if</span> (FAILED(hr))
00453             <span class="keywordflow">return</span> NULL;
00454 
00455         <span class="keywordflow">return</span> InsertedNodePtr;
00456     }
00457 
00458 }; <span class="comment">// class CSettingsStorageMSXML</span>
00459 
<a name="l00461"></a><a class="code" href="classCSettingsStorageMSXMLFile.html">00461</a> <span class="keyword">class </span><a class="code" href="classCSettingsStorageMSXMLFile.html">CSettingsStorageMSXMLFile</a> : <span class="keyword">public</span> <a class="code" href="classCSettingsStorageMSXML.html">CSettingsStorageMSXML</a>
00462 {
00463 <span class="keyword">public</span>:
00464     <a class="code" href="classCSettingsStorageMSXMLFile.html">CSettingsStorageMSXMLFile</a>()
00465     {
00466         m_XMLFileName[0] = 0;
00467         m_RootElementName[0] = 0;
00468     }
00469 
<a name="l00471"></a><a class="code" href="classCSettingsStorageMSXMLFile.html#a1">00471</a>     <a class="code" href="classCSettingsStorageMSXMLFile.html">CSettingsStorageMSXMLFile</a>(LPCTSTR FileName, LPCTSTR RootElementName)
00472     {
00473         m_XMLFileName[0] = 0;
00474         m_RootElementName[0] = 0;
00475         SetXMLFileName(FileName, RootElementName);
00476     }
00477 
<a name="l00482"></a><a class="code" href="classCSettingsStorageMSXMLFile.html#a2">00482</a>     <span class="keywordtype">void</span> SetXMLFileName(LPCTSTR FileName, LPCTSTR RootElementName)
00483     {
00484         <span class="keywordflow">if</span> (FileName) _tcsncpy(m_XMLFileName, FileName, MAX_PATH);
00485         <span class="keywordflow">if</span> (RootElementName) _tcsncpy(m_RootElementName, RootElementName, MAX_PATH);
00486     }
00487 
00488     <span class="keywordtype">bool</span> OnBeforeLoad()
00489     {
00490         HRESULT hr;
00491 
00492         <span class="comment">// Create DOMDocument and load it</span>
00493         hr = m_DocumentPtr.CreateInstance(_T(<span class="stringliteral">"Msxml2.DOMDocument"</span>));
00494         <span class="keywordflow">if</span> (FAILED(hr))
00495             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00496 
00497         <span class="comment">// Prepare the filename in case of relative path</span>
00498         _bstr_t URLName;        
00499         <span class="keywordflow">if</span> (m_XMLFileName[1] != <span class="charliteral">':'</span>)
00500         {
00501             TCHAR CurDir[MAX_PATH];
00502             GetCurrentDirectory(MAX_PATH, CurDir);
00503             URLName += CurDir;
00504             URLName += <span class="stringliteral">"\\"</span>;
00505         }
00506         URLName += m_XMLFileName;
00507 
00508         <span class="comment">// Note that if load returns S_FALSE to indicate it can't, this is</span>
00509         <span class="comment">// ok for us, because the SETTING_ITEM_ might all be non _REQUIRE ones.</span>
00510         VARIANT_BOOL LoadOk;
00511         hr = m_DocumentPtr-&gt;load(_variant_t(URLName), &amp;LoadOk);
00512         <span class="keywordflow">if</span> (FAILED(hr))
00513             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00514 
00515         <span class="keywordflow">if</span> (LoadOk)
00516         {
00517             IXMLDOMElementPtr RootNodePtr;
00518             hr = m_DocumentPtr-&gt;get_documentElement(&amp;RootNodePtr);
00519             <span class="keywordflow">if</span> (FAILED(hr))
00520                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00521 
00522             m_NodePtr = RootNodePtr;
00523             <span class="keywordflow">return</span> <span class="keyword">true</span>;
00524         }
00525         <span class="keywordflow">else</span>
00526         {
00527             <span class="comment">// The current Document is empty, so create the root node so that any subitem behaves correctly</span>
00528             m_NodePtr = CreateChildNode(m_DocumentPtr, m_RootElementName);
00529             <span class="keywordflow">return</span> m_NodePtr;
00530         }
00531     }
00532 
00533     <span class="keywordtype">bool</span> OnAfterLoad()
00534     {
00535         m_NodePtr = NULL;
00536 
00537         <span class="comment">// Destroy the DOMDocument</span>
00538         m_DocumentPtr = NULL;
00539 
00540         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00541     }
00542 
00543     <span class="keywordtype">bool</span> OnBeforeSave()
00544     {
00545         HRESULT hr;
00546 
00547         <span class="comment">// Create DOMDocument</span>
00548         hr = m_DocumentPtr.CreateInstance(_T(<span class="stringliteral">"Msxml2.DOMDocument"</span>));
00549         <span class="keywordflow">if</span> (FAILED(hr))
00550             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00551 
00552         <span class="comment">// create the root element</span>
00553         m_NodePtr = CreateChildNode(m_DocumentPtr, m_RootElementName);
00554         <span class="keywordflow">return</span> m_NodePtr;
00555     }
00556 
00557     <span class="keywordtype">bool</span> OnAfterSave()
00558     {
00559         HRESULT hr;
00560 
00561         <span class="comment">// Save the DOMDocument to file</span>
00562         hr = m_DocumentPtr-&gt;save(_variant_t(m_XMLFileName));
00563 
00564         <span class="comment">// Destroy the DOMDocument</span>
00565         m_DocumentPtr = NULL;
00566 
00567         <span class="keywordflow">return</span> SUCCEEDED(hr);
00568     }
00569 
00570 <span class="keyword">protected</span>:
00571     TCHAR m_XMLFileName[MAX_PATH];
00572     TCHAR m_RootElementName[MAX_PATH];
00573 };
00574 
00575 
00576 }; <span class="comment">// namespace Mortimer</span>
00577 
00578 <span class="preprocessor">#endif // __MORTIMER_SETTINGSSTORAGERMSXML_H__</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri May 28 11:14:20 2004 for SettingsStorage by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.5 </small></address>
</body>
</html>
