<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SettingsStorage: Main Page</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.5 -->
<div class="qindex"><a class="qindexHL" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a></div>
<h1>SettingsStorage Documentation</h1>
<p>
<h2><a class="anchor" name="Introduction">
Introduction</a></h2>
Program settings is something that many of us implemented. If I look at myself, I implemented this in various ways, depending on the framework (MFC, ATL, ...) and also on the data types to handle. One more element is where to put the settings ? In the registry, in a file, as XML or in a database ?<p>
This article provides a single solution to handle program settings with little to no code, but taking into account the framework you work on and the storage scheme you desire.<h2><a class="anchor" name="Background">
Background</a></h2>
Generally, I create a class with data members (the settings) and a <code>Load/Save</code> pair of function. Here is what it looks like:<p>
<div class="fragment"><pre><span class="keyword">class </span>CMySettings
{
<span class="keyword">public</span>:
    <span class="keywordtype">bool</span> Load(...);
    <span class="keywordtype">bool</span> Save(...);

    CString WindowName;
    <span class="keywordtype">int</span> Height;
    <span class="keywordtype">int</span> Width;
    COLORREF BackColor;
};
</pre></div><p>
Of course, the content of Load/Save has to be done by hand. For example it could use the registry with <code>RegCreateKey()</code>, <code>RegSetValue()</code> and so on.<p>
When it comes to handle collections (Arrays), the Load/Save functions receives more code with a loop for each collection. It becomes cumbersome.<p>
In another program or even the same one but with a different settings class, I rewrite the Load/Save functions for the new data members. In fact, I copy/paste code from the previous functions and modify it a bit.<p>
It's exactly this process that I want no more. It's time consuming and not error prone due to copy/paste.<h2><a class="anchor" name="Hunting">
Hunting for a settings class</a></h2>
Before re-inventing the wheel, I though "someone out there surely already made a cool class". This started my hunting. I Found classes here and there, some that did not more than the one described above, some others that were worst. And finally I found CRegSettings here at CodeProject.<p>
CRegSettings is made by Magomed G. Abdurakhmanov. This is a really cool class. It uses the MAP mechanism like MFC or ATL maps (msg, com, ddx).The map is here to avoid writing the Load/Save functions. Exactly what I wanted.<p>
Here is an example of a settings class:<p>
<div class="fragment"><pre><span class="keyword">class </span>CMySettings : <span class="keyword">public</span> CRegSettings
{
<span class="keyword">public</span>:
    CString WindowName;
    <span class="keywordtype">int</span> Height;
    <span class="keywordtype">int</span> Width;
    COLORREF BackColor;

    BEGIN_REG_MAP(CMySettings)
        REG_ITEM(WindowName, <span class="stringliteral">"No Document"</span>)
        REG_ITEM_REQUIRE(Height)
        REG_ITEM_REQUIRE(Width)
        REG_ITEM(BackColor, 0xFF8800)
    END_REG_MAP()
};
</pre></div><p>
Somewhere in the program code, you call the Load/Save functions. Example: <code>m_Settings.Load()</code>;<p>
You may ask: "Okay, what is this article for if you found the Grail?". Because registry is not the place I always want my settings to go to.<h2><a class="anchor" name="Whatsnew">
What's new ?</a></h2>
The main idea of my system is to split the settings class into two classes. One which handle the data members and the Load/Save operations for all the fields, the second which handle single item reading and writing for a specific storage mechanism.<p>
The goal is to have the settings class to be separated from the way items are stored. This lets you choose which storage mechanism to use at run time.<p>
With a small effort, you can also add new storage schemes to the system yourself. All the tedious work is already done, so you can concentrate on the real code.<h2><a class="anchor" name="HowToUse">
How to simply use it ?</a></h2>
I'll explain here the different steps to define a class that manage some settings.<h3><a class="anchor" name="Step1">
Step 1</a></h3>
Derive your class from <a class="el" href="classCSettings.html">CSettings</a>. <br>
 Note that <a class="el" href="classCSettings.html">CSettings</a> is encapsulated in the <code>Mortimer</code> namespace. <br>
 Add data members that represent your settings. <br>
<p>
Here is an example:<p>
<div class="fragment"><pre><span class="preprocessor">#include &lt;MSettingsStorage.h&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace </span>Mortimer;

<span class="keyword">class </span>CMySettings : <span class="keyword">public</span> <a class="code" href="classCSettings.html">CSettings</a>
{
<span class="keyword">public</span>:
    CString WindowName;
    <span class="keywordtype">int</span> Height;
    <span class="keywordtype">int</span> Width;
    COLORREF BackColor;
    CDWordArray Measures;
};
</pre></div><h3><a class="anchor" name="Step2">
Step 2</a></h3>
Add a map entry for each data member.<p>
Each handled data type or group of data types provides three map macros, here are the macros for the simple types:<ul>
<li>SETTING_ITEM(&lt;data member name&gt;)</li><li>SETTING_ITEM_REQUIRE(&lt;data member name&gt;)</li><li>SETTING_ITEM_DEFAULT(&lt;data member name&gt;, &lt;expression for default value&gt;)</li></ul>
<p>
The standard one simply takes the handled data member name as argument. If at <a class="el" href="classCSettings.html#a0">CSettings::Load()</a> time the item fails to read its data, the whole Load() process will quietly continue and could return success (if no required item generates an error).<p>
The REQUIRE one changes this behaviour, as his name involves the item is required, so a failed read will return failure for the Load() process. Note that other items may be read depending on <a class="el" href="classCSettingsStorage.html#z3_1">CSettingsStorage::ContinueOnError()</a>.<p>
The DEFAULT one will act like the standard but when the item fails to read, the item data is replaced with the given default value.<p>
When saving (<a class="el" href="classCSettings.html#a1">CSettings::Save()</a>) any of these macros may fail and will return the error status. Other items may be saved further depending on the value of the <a class="el" href="classCSettingsStorage.html#z3_1">CSettingsStorage::ContinueOnError()</a> function.<p>
Here is the list of handled types for each macro.<p>
<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td valign="top"><p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><b>SETTING_ITEM</b></td><th><em>all integer types:</em>  </th></tr>
<tr>
<td></td><td>LONGLONG, ULONGLONG  </td></tr>
<tr>
<td></td><td>long, unsigned long  </td></tr>
<tr>
<td></td><td>int, unsigned int  </td></tr>
<tr>
<td></td><td>short, unsigned short  </td></tr>
<tr>
<td></td><td>char (signed), unsigned char (Treated as numbers)  </td></tr>
<tr>
<td></td><th><em>simple types:</em>  </th></tr>
<tr>
<td></td><td>float, double, bool  </td></tr>
<tr>
<td></td><th><em>Strings:</em>  </th></tr>
<tr>
<td></td><td>CString, std::string, std::wstring  </td></tr>
<tr>
<td><b>SETTING_ITEM_SZ</b></td><th><em>Zero Terminated Strings</em>  </th></tr>
<tr>
<td><b>SETTING_ITEM_BINARY</b></td><th><em>Any data</em>  </th></tr>
<tr>
<td><b>SETTING_ITEM_BINARYPTR</b></td><th><em>Any data behind a pointer</em>  </th></tr>
</table>
<p>
</td><td valign="top"><p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><b>SETTING_ITEM_ARRAY</b></td><th><em>CArray</em><br>
of <a class="el" href="classCSettings.html">CSettings</a> subclasses  </th></tr>
<tr>
<td></td><td>ATL CSimpleArray&lt;&gt;  </td></tr>
<tr>
<td></td><td>MFC CArray&lt;&gt;  </td></tr>
<tr>
<td></td><td>MFC CxxxArray  </td></tr>
<tr>
<td><b>SETTING_ITEM_STL</b></td><th><em>STL collections</em><br>
of <a class="el" href="classCSettings.html">CSettings</a> subclasses  </th></tr>
<tr>
<td></td><td>std::vector  </td></tr>
<tr>
<td></td><td>std::deque  </td></tr>
<tr>
<td></td><td>std::list  </td></tr>
<tr>
<td><b>SETTING_ITEM_ALONE_ARRAY</b></td><th><em>CArray</em><br>
of standalone types  </th></tr>
<tr>
<td></td><td>ATL CSimpleArray&lt;&gt;  </td></tr>
<tr>
<td></td><td>MFC CArray&lt;&gt;  </td></tr>
<tr>
<td></td><td>MFC CxxxArray  </td></tr>
<tr>
<td><b>SETTING_ITEM_ALONE_STL</b></td><th><em>STL collections</em><br>
of standalone types  </th></tr>
<tr>
<td></td><td>std::vector  </td></tr>
<tr>
<td></td><td>std::deque  </td></tr>
<tr>
<td></td><td>std::list  </td></tr>
</table>
<p>
</td></tr>
</table>
<p>
Standalone types are all the types handled by SETTING_ITEM.<p>
The example with the map:<p>
<div class="fragment"><pre><span class="keyword">class </span>CMySettings : <span class="keyword">public</span> <a class="code" href="classCSettings.html">CSettings</a>
{
<span class="keyword">public</span>:
    CString WindowName;
    <span class="keywordtype">int</span> Height;
    <span class="keywordtype">int</span> Width;
    COLORREF BackColor;
    CDWordArray Measures;

    BEGIN_SETTING_MAP(CMySettings)
        SETTING_ITEM_DEFAULT(WindowName, <span class="stringliteral">"MyApp"</span>)
        SETTING_ITEM_REQUIRE(Height)
        SETTING_ITEM_REQUIRE(Width)
        SETTING_ITEM(BackColor)
        SETTING_ITEM_ALONE_ARRAY(Measures, DWORD)
    END_SETTING_MAP()
};
</pre></div><p>
Note the additional argument for SETTING_ITEM_ALONE_ARRAY, you have to pass the type of the elements.<h3><a class="anchor" name="Step3">
Step 3</a></h3>
Now that you have your settings class defined, you have to load and save these settings. This is done somewhere in your code by called the settings class Load() and Save() functions.<p>
To be able to call these, you have to pass a <a class="el" href="classCSettingsStorage.html">CSettingsStorage</a> object. This object makes the link with the underlying storage scheme.<p>
Let's go with an example using the Registry for the storage.<p>
<div class="fragment"><pre><span class="preprocessor">#include &lt;MSettingsStorageRegistry.h&gt;</span>
<span class="keyword">using</span> Mortimer::CSettingsStorageRegistry;

<span class="preprocessor">#define APP_REGISTRY_KEY "Software\\Company\\MyApp"</span>
<span class="preprocessor"></span>
<span class="keyword">class </span>CMyApp : <span class="keyword">public</span> CSomeFrameworkApp
{
<span class="keyword">public</span>:

    ...

    <span class="keywordtype">void</span> OnInit()
    {
        <a class="code" href="classCSettingsStorageRegistry.html">CSettingsStorageRegistry</a> Stg(HKEY_CURRENT_USER, APP_REGISTRY_KEY);
        m_MySettings.Load(Stg);
    }

    <span class="keywordtype">void</span> OnChangeSettings()
    {
        CSettingsDialog Dlg;
        <span class="keywordflow">if</span> (Dlg.DoModal() == IDOK)
        {
            <a class="code" href="classCSettingsStorageRegistry.html">CSettingsStorageRegistry</a> Stg(HKEY_CURRENT_USER, APP_REGISTRY_KEY);
            m_MySettings.Save(Stg);
        }
    }

    ...

protected:
    CMySettings m_MySettings;

};
</pre></div><p>
Any error handling has been omitted for clarity.<p>
Well, it's that simple. Nothing more is needed.<h2><a class="anchor" name="StorageScheme">
How to implement a new storage scheme ?</a></h2>
I created three classes that manage storage schemes:<ul>
<li><a class="el" href="classCSettingsStorageRegistry.html">CSettingsStorageRegistry</a> to handle the Registry</li><li><a class="el" href="classCSettingsStorageIniFile.html">CSettingsStorageIniFile</a> to handle .ini files</li><li><a class="el" href="classCSettingsStorageMSXMLFile.html">CSettingsStorageMSXMLFile</a> to handle XML files (by using msxml.dll)</li></ul>
<p>
You can add your own storage schemes by deriving your new class from the abstract class <a class="el" href="classCSettingsStorage.html">CSettingsStorage</a> and implementing the SaveLoadItem() functions for each handled type. For details, please refer to the documentation of this class. You may also investigate the supplied classes.<h2><a class="anchor" name="Conclusion">
Conclusion</a></h2>
You should now be able to handle your settings more easily, even with your own types or collections. To get a real example read the demo project, it shows you some advanced use. Three examples are present, one for the MFC framework, one for ATL/WTL and the last is a simple one for plain Win32 using STL.<p>
Feel free to use and modify this piece of software. Suggestions and comments are also welcomed.<p>
Stay tuned for a next article. I'll cover using this settings system tightened with dialogs to edit them, of course with minimum code.<h2><a class="anchor" name="History">
History</a></h2>
<ul>
<li>28 may 2004<ul>
<li>Added class to handle XML : CSettingsStorageMSXML*</li></ul>
</li><li>14 may 2004<ul>
<li>Bug fixes.</li><li><a class="el" href="classCSettingsStorage.html">CSettingsStorage</a> reworked to add standard behaviour. <br>
 WARNING: There's a compatibility issue for INI Files. The 'Count' value for collections is now stored under 'Root.KeyName'-'Count' instead of 'Root'-'KeyName.Count'</li><li>SETTING_ITEM_ALONE_* macros added. <br>
 Thanks to Mr. CoolVini for this idea.</li></ul>
</li><li>5 april 2004<ul>
<li>Article submitted</li></ul>
</li><li>31 december 2003<ul>
<li>First release </li></ul>
</li></ul>
<hr size="1"><address style="align: right;"><small>Generated on Fri May 28 11:14:20 2004 for SettingsStorage by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.5 </small></address>
</body>
</html>
